
//	***************************************************************************
//
//  Project for testing IR transmit and recieve functions together 
//
//	***************************************************************************

//	module break ( clk, slow_clk, rst_n, sense, sense_hold, LED0, LED9, count, Tens, Ones, HEX0, HEX1);
	module break ( clk, rst_n, sense, LED0, LED9, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, slow_clk);
	

		input 					   clk							;	//	50 MHz system clock
		input							rst_n							;	// System reset set to SW[0] - PIN_AB30
		input							sense							;	//	Can be set to any GPIO pin - for this project set to PIN_AA12 PIN 40 on GPIO
		
		output	reg				LED0 							;	// LEDR[0] - 1st LED fto show rst_n = 0, reset on and LEDR[0]] is on
		output	reg				LED9 							;	// LEDR[9] - last LED whcih changes state on/off when object detected.
		
		output	wire	[6:0]		HEX0							;	// object count converted to  BCD and output on 2 most left 7-segment
		output	wire	[6:0]		HEX1							;
		output			[6:0]		HEX2 = 7'b1111111			;	// blank
		output			[6:0]		HEX3 = 7'b1111111			;	// blank
		output			[6:0]		HEX4 = 7'b1111111			;	// blank
		output			[6:0]		HEX5 = 7'b1111111			;	// blank
		
		output	reg 				slow_clk 					;	//	slowed down clock to about 500 Hz or 2 ms
					reg 				sense_hold					;	//	holds the previosu stated of the count - sensed or not sensed
					reg 	[9:0]		count = 0					;	//	object count
					wire 	[3:0]		Ones 							;	// 1's  diget of BCD count in HEX0
					wire 	[3:0]		Tens 							;	// 10's diget of BCD count in HEX1
		
		
//	*********************************
		
		
		always @(posedge clk )										//	block to detect reset and manage reset LED
			begin

				if ( !rst_n )											// If reset is asserted
					begin
						LED0 <= 1									;	// reset asserted
					end
				
				else
					begin
						LED0 <= 0									;	// reset NOT asserted
					end
			end
			
// *******************************************************
			
		always @ (posedge slow_clk)	
			begin
				
				if ( !rst_n )							
					begin
						count <= 0									;	// reset count if reset asserted
						LED9 <= 0									;	// if reset, turn off object detect
					end 
					
				else 
					begin
						if ( !sense )									// 
							begin
								if ( sense_hold != sense)			//	check if "sense" state has changed
									begin
										sense_hold <= sense		;	//	change current sense state
										count <= count + 1'b1	;	// increment object count
										LED9 <= !LED9				;	// compliment object count LED
									end 	
							end
	
						else 
							begin
								sense_hold <= sense				;	// if not detected, - update sense state  
							end
						
					end		
			end
	
// *******************************************************
	
	
	integer		clk_count = 100000							;	// slow clock count for 500 Hz or 2 ms
//	integer		clk_count = 2									;	// slow clock count for simulation and test
	integer		i = 0												;
		
	always @ (posedge clk)
		begin																											
			i= i + 1													;	// increment slow clock counter
			
			if ( !rst_n ) 
				begin
					slow_clk <= 1'b0								;	// if reset - reset slow clock counter
					i <= 0											;	
				end
			
			else
				begin
					if (i >= clk_count)								// counter reached max count
					begin
						i <= 0										;	//	reset counter
						slow_clk <= !slow_clk					;	// compliment slow clock
					end
				end
		end

// *******************************************************	
	
			
			bcd ( count,Tens, Ones )							;	// convert count to BCD
			Hex_7Seg h0 ( Ones,  HEX0 )						;	// output lower (1's)  diget
			Hex_7Seg h1 ( Tens,  HEX1 )						;	// output upper (10's) diget			
					
endmodule



// ******************************************************************** 
//
///	BCD conversion
//
// ********************************************************************

	module bcd ( number, tens, ones )						;	// convert count to BCD 10's and 1's

// I/O Signal Definitions
	input  			[9:0]	number								;
	output	reg	[3:0]	tens = 0								;
	output	reg	[3:0] ones = 0								;

		always @(number)
			begin
				
				if (number >= 30) 
					begin
						tens = 3										;
						ones = number - 30						;
					end
			
				else if (number >= 20)
					begin
						tens = 2										;
						ones = number - 20						;
					end

				else if (number >= 10)
					begin
						tens = 1										;
						ones = number - 10						;
					end
			
				else if (number < 10)
					begin
						tens = 0										;
						ones = number								;
					end
					
				else
					begin
						tens = 0										;
						ones = 0										;
					end
			
			end
endmodule	




// ******************************************************************** 
//
//		SEG HEX decoder
//
// ********************************************************************
	
		module Hex_7Seg ( iNum, oHex )						;	//	output BCD diget
		
		input				[3:0]		iNum							;	// Binary input 		(4 -bits)
		output	reg	[6:0]		oHex							;	//	HEX 7-SEG Output	(7-bits)

		always @(iNum) 
	        begin
				case(iNum)
					4'h0: 	oHex <= 7'b1000000				; //0  
					4'h1: 	oHex <= 7'b1111001				; //1
					4'h2: 	oHex <= 7'b0100100				; //2
					4'h3: 	oHex <= 7'b0110000				; //3
					4'h4: 	oHex <= 7'b0011001				; //4
					4'h5: 	oHex <= 7'b0010010				; //5
					4'h6: 	oHex <= 7'b0000010				; //6
					4'h7: 	oHex <= 7'b1111000				; //7
					4'h8: 	oHex <= 7'b0000000				; //8
					4'h9: 	oHex <= 7'b0011000				; //9
//					4'ha: 	oHex <= 7'b0001000				; //a
//					4'hb: 	oHex <= 7'b0000011				; //b
//					4'hc: 	oHex <= 7'b1000110				; //c
//					4'hd: 	oHex <= 7'b0100001				; //d
//					4'he: 	oHex <= 7'b0000110				; //e
//					4'hf: 	oHex <= 7'b0001110				; //f
					default:	oHex <= 7'b1000000				; //0
				endcase
			end
endmodule
